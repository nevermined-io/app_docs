"use strict";(self.webpackChunkapp_docs=self.webpackChunkapp_docs||[]).push([[6746],{3905:(t,e,r)=>{r.d(e,{Zo:()=>u,kt:()=>d});var n=r(7294);function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function i(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function a(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?i(Object(r),!0).forEach((function(e){o(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function c(t,e){if(null==t)return{};var r,n,o=function(t,e){if(null==t)return{};var r,n,o={},i=Object.keys(t);for(n=0;n<i.length;n++)r=i[n],e.indexOf(r)>=0||(o[r]=t[r]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(n=0;n<i.length;n++)r=i[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(o[r]=t[r])}return o}var s=n.createContext({}),l=function(t){var e=n.useContext(s),r=e;return t&&(r="function"==typeof t?t(e):a(a({},e),t)),r},u=function(t){var e=l(t.components);return n.createElement(s.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var r=t.components,o=t.mdxType,i=t.originalType,s=t.parentName,u=c(t,["components","mdxType","originalType","parentName"]),m=l(r),d=o,h=m["".concat(s,".").concat(d)]||m[d]||p[d]||i;return r?n.createElement(h,a(a({ref:e},u),{},{components:r})):n.createElement(h,a({ref:e},u))}));function d(t,e){var r=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=r.length,a=new Array(i);a[0]=m;var c={};for(var s in e)hasOwnProperty.call(e,s)&&(c[s]=e[s]);c.originalType=t,c.mdxType="string"==typeof t?t:o,a[1]=c;for(var l=2;l<i;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},2007:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var n=r(7462),o=(r(7294),r(3905));const i={sidebar_position:15,description:"How to use Subscription NFTs to protect Smart Contracts"},a="How to use Subscription NFTs to protect Smart Contracts?",c={unversionedId:"tutorials/smart-contract-access",id:"tutorials/smart-contract-access",title:"How to use Subscription NFTs to protect Smart Contracts?",description:"How to use Subscription NFTs to protect Smart Contracts",source:"@site/docs/tutorials/15-smart-contract-access.md",sourceDirName:"tutorials",slug:"/tutorials/smart-contract-access",permalink:"/docs/tutorials/smart-contract-access",draft:!1,editUrl:"https://github.com/nevermined-io/app_docs/tree/main/docs/tutorials/15-smart-contract-access.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15,description:"How to use Subscription NFTs to protect Smart Contracts"},sidebar:"tutorialSidebar",previous:{title:"How to integrate a web service in an application",permalink:"/docs/tutorials/webservice-integration"},next:{title:"Getting tokens from faucets in testing environments",permalink:"/docs/tutorials/faucets"}},s={},l=[{value:"Getting ready",id:"getting-ready",level:2},{value:"How to integrate the Subscription NFT in your Smart Contract",id:"how-to-integrate-the-subscription-nft-in-your-smart-contract",level:2},{value:"1. Define which methods you want to protect",id:"1-define-which-methods-you-want-to-protect",level:3},{value:"2. Integrate with the Subscription NFT",id:"2-integrate-with-the-subscription-nft",level:3},{value:"3. Implement the access control to check if the caller is a subscriber",id:"3-implement-the-access-control-to-check-if-the-caller-is-a-subscriber",level:3},{value:"4. Testing the integration",id:"4-testing-the-integration",level:3}],u={toc:l};function p(t){let{components:e,...r}=t;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-to-use-subscription-nfts-to-protect-smart-contracts"},"How to use Subscription NFTs to protect Smart Contracts?"),(0,o.kt)("p",null,"In this tutorial we show how a Smart Contract developer can control which external users can call the contract logic. We explain how you can use Subscription NFTs to limit the ability to execute certain Smart Contract functionalities to holders of an NFT."),(0,o.kt)("h2",{id:"getting-ready"},"Getting ready"),(0,o.kt)("p",null,"First you will need to create your own Subscription NFT for your Smart Contract (instructions ",(0,o.kt)("a",{parentName:"p",href:"/docs/tutorials/create-subscription"},"here"),")."),(0,o.kt)("admonition",{title:"Tutorial",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"All the code used in this tutorial is available in this ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"https://github.com/nevermined-io/tutorials/tree/main/subscriptions/001-Smart_Contract_Access"},"repository")))),(0,o.kt)("h2",{id:"how-to-integrate-the-subscription-nft-in-your-smart-contract"},"How to integrate the Subscription NFT in your Smart Contract"),(0,o.kt)("p",null,"The steps to integrate are the following:"),(0,o.kt)("h3",{id:"1-define-which-methods-you-want-to-protect"},"1. Define which methods you want to protect"),(0,o.kt)("p",null,"First you need to decide what you need to protect. This is totally dependent on your Smart Contract logic. In our example we are going to protect the ",(0,o.kt)("inlineCode",{parentName:"p"},"claim")," method. This method is used to claim a giveaway in an ERC20 token contract."),(0,o.kt)("h3",{id:"2-integrate-with-the-subscription-nft"},"2. Integrate with the Subscription NFT"),(0,o.kt)("p",null,"Next, you need to link the Solidity code of your Smart Contract with the Subscription NFT contract. Because the Nevermined contract uses the ERC721 format, you can use the standard ERC721 interfaces to interact with it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"IERC721 subscriptionNFT = IERC721(subscriptionNFTAddress);\n")),(0,o.kt)("h3",{id:"3-implement-the-access-control-to-check-if-the-caller-is-a-subscriber"},"3. Implement the access control to check if the caller is a subscriber"),(0,o.kt)("p",null,"In our example we are going to protect the ",(0,o.kt)("inlineCode",{parentName:"p"},"claim")," method. This method is used to claim a giveaway in an ERC20 token contract. We want to protect this method so only subscribers of our NFT can call it. First we create a modifier to check if the caller of the smart contract is a subscriber."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    modifier onlySubscribers(address _address) {\n        require(\n            subscriptionNFT.balanceOf(_address) > 0,\n            'You are not a subscriber'\n        );\n        _;\n    }\n")),(0,o.kt)("p",null,"Next, we use this modifier in the ",(0,o.kt)("inlineCode",{parentName:"p"},"claim")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"    function claim() public onlySubscribers(msg.sender) {\n        // ...\n    }\n")),(0,o.kt)("p",null,"You can see all the contract code ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nevermined-io/tutorials/blob/main/subscriptions/001-Smart_Contract_Access/contracts/MyToken.sol"},"here"),"."),(0,o.kt)("h3",{id:"4-testing-the-integration"},"4. Testing the integration"),(0,o.kt)("p",null,"You can the complete the test ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nevermined-io/tutorials/blob/main/subscriptions/001-Smart_Contract_Access/test/MyToken.ts"},"here"),"."))}p.isMDXComponent=!0}}]);