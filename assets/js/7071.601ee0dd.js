"use strict";(self.webpackChunkapp_docs=self.webpackChunkapp_docs||[]).push([[7071],{5699:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Environments=void 0,t.Environments={appStaging:{frontend:"https://staging.nevermined.app",backend:"https://one-backend.staging.nevermined.app"},appTesting:{frontend:"https://testing.nevermined.app",backend:"https://one-backend.testing.nevermined.app"},appArbitrum:{frontend:"https://nevermined.app",backend:"https://one-backend.arbitrum.nevermined.app"},appGnosis:{frontend:"https://gnosis.nevermined.app",backend:"https://one-backend.gnosis.nevermined.app"},appMatic:{frontend:"https://matic.nevermined.app",backend:"https://one-backend.matic.nevermined.app"}}},7691:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),a(r(8661),t),a(r(5699),t)},8661:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Payments=void 0;const n=r(74),a=r(5699);t.Payments=class{constructor(e){this.returnUrl=e.returnUrl,this.environment=a.Environments[e.environment],this.appId=e.appId,this.version=e.version}connect(){const e=new URL(`/en/login?nvm-export=session-key&returnUrl=${this.returnUrl}`,this.environment.frontend);window.location.href=e.toString()}init(){const e=new URL(window.location.href),t=e.searchParams.get("sessionKey");if(t){const r=(0,n.decodeJwt)(t);this.sessionKey=r.sessionKey,e.searchParams.delete("sessionKey"),history.replaceState(history.state,"",e.toString())}}logout(){this.sessionKey=void 0}get isLoggedIn(){return!!this.sessionKey}async createSubscription({name:e,description:t,price:r,tokenAddress:n,amountOfCredits:a,duration:i,tags:s}){const o={sessionKey:this.sessionKey,name:e,description:t,price:r.toString(),tokenAddress:n,amountOfCredits:a,duration:i,tags:s},c={method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(o)},d=new URL("/api/v1/payments/subscription",this.environment.backend),p=await fetch(d,c);if(!p.ok)throw Error(p.statusText);return p.json()}async createService({subscriptionDid:e,name:t,description:r,price:n,tokenAddress:a,amountOfCredits:i,duration:s,tags:o,serviceChargeType:c,minCreditsToCharge:d,maxCreditsToCharge:p,authType:h,username:u,password:l,token:y,endpoints:w,openEndpoints:f,openApiUrl:m,integration:g,sampleLink:E,apiDescription:S,curation:A}){const b={sessionKey:this.sessionKey,name:t,description:r,price:n.toString(),tokenAddress:a,amountOfCredits:i,duration:s,tags:o,subscriptionDid:e,serviceChargeType:c,minCreditsToCharge:d,maxCreditsToCharge:p,authType:h,username:u,password:l,token:y,endpoints:w,openEndpoints:f,openApiUrl:m,integration:g,sampleLink:E,apiDescription:S,curation:A},v={method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(b)},_=new URL("/api/v1/payments/service",this.environment.backend),H=await fetch(_,v);if(!H.ok)throw Error(H.statusText);return H.json()}async createFile({subscriptionDid:e,assetType:t,name:r,description:n,files:a,price:i,tokenAddress:s,amountOfCredits:o,duration:c,tags:d,dataSchema:p,sampleCode:h,filesFormat:u,usageExample:l,programmingLanguage:y,framework:w,task:f,trainingDetails:m,variations:g,fineTunable:E,minCreditsToCharge:S,maxCreditsToCharge:A,curation:b}){const v={sessionKey:this.sessionKey,assetType:t,name:r,description:n,files:a,price:i.toString(),tokenAddress:s,amountOfCredits:o,duration:c,tags:d,subscriptionDid:e,dataSchema:p,sampleCode:h,filesFormat:u,usageExample:l,programmingLanguage:y,framework:w,task:f,trainingDetails:m,variations:g,fineTunable:E,minCreditsToCharge:S,maxCreditsToCharge:A,curation:b},_={method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(v)},H=new URL("/api/v1/payments/file",this.environment.backend),C=await fetch(H,_);if(!C.ok)throw Error(C.statusText);return C.json()}getSubscriptionDetails(e){const t=new URL(`/en/subscription/${e}`,this.environment.frontend);window.location.href=t.toString()}getServiceDetails(e){const t=new URL(`/en/webservice/${e}`,this.environment.frontend);window.location.href=t.toString()}getFileDetails(e){const t=new URL(`/en/file/${e}`,this.environment.frontend);window.location.href=t.toString()}checkoutSubscription(e){const t=new URL(`/en/subscription/checkout/${e}`,this.environment.frontend);window.location.href=t.toString()}}},1151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>s});var n=r(7294);const a={},i=n.createContext(a);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:t},e.children)}},74:(e,t,r)=>{r.r(t),r.d(t,{CompactEncrypt:()=>ct,CompactSign:()=>ht,EmbeddedJWK:()=>At,EncryptJWT:()=>mt,FlattenedEncrypt:()=>Ge,FlattenedSign:()=>pt,GeneralEncrypt:()=>Ve,GeneralSign:()=>lt,SignJWT:()=>ft,UnsecuredJWT:()=>Tt,base64url:()=>a,calculateJwkThumbprint:()=>Et,calculateJwkThumbprintUri:()=>St,compactDecrypt:()=>De,compactVerify:()=>Ze,createLocalJWKSet:()=>Ct,createRemoteJWKSet:()=>Wt,cryptoRuntime:()=>Mt,decodeJwt:()=>It,decodeProtectedHeader:()=>Ut,errors:()=>n,exportJWK:()=>$e,exportPKCS8:()=>Ne,exportSPKI:()=>je,flattenedDecrypt:()=>Oe,flattenedVerify:()=>qe,generalDecrypt:()=>xe,generalVerify:()=>Qe,generateKeyPair:()=>Dt,generateSecret:()=>xt,importJWK:()=>We,importPKCS8:()=>Ke,importSPKI:()=>Pe,importX509:()=>ke,jwtDecrypt:()=>ot,jwtVerify:()=>st});var n={};r.r(n),r.d(n,{JOSEAlgNotAllowed:()=>v,JOSEError:()=>S,JOSENotSupported:()=>_,JWEDecryptionFailed:()=>H,JWEInvalid:()=>C,JWKInvalid:()=>K,JWKSInvalid:()=>W,JWKSMultipleMatchingKeys:()=>J,JWKSNoMatchingKey:()=>T,JWKSTimeout:()=>R,JWSInvalid:()=>P,JWSSignatureVerificationFailed:()=>U,JWTClaimValidationFailed:()=>A,JWTExpired:()=>b,JWTInvalid:()=>k});var a={};r.r(a),r.d(a,{decode:()=>Rt,encode:()=>Jt});const i=crypto,s=e=>e instanceof CryptoKey,o=async(e,t)=>{const r=`SHA-${e.slice(-3)}`;return new Uint8Array(await i.subtle.digest(r,t))},c=new TextEncoder,d=new TextDecoder,p=2**32;function h(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}function u(e,t,r){if(t<0||t>=p)throw new RangeError(`value must be >= 0 and <= ${p-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function l(e){const t=Math.floor(e/p),r=e%p,n=new Uint8Array(8);return u(n,t,0),u(n,r,4),n}function y(e){const t=new Uint8Array(4);return u(t,e),t}function w(e){return h(y(e.length),e)}const f=e=>{let t=e;"string"==typeof t&&(t=c.encode(t));const r=[];for(let n=0;n<t.length;n+=32768)r.push(String.fromCharCode.apply(null,t.subarray(n,n+32768)));return btoa(r.join(""))},m=e=>f(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),g=e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},E=e=>{let t=e;t instanceof Uint8Array&&(t=d.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return g(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class S extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class A extends S{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}}class b extends S{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}}class v extends S{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class _ extends S{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class H extends S{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class C extends S{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class P extends S{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class k extends S{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class K extends S{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class W extends S{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class T extends S{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class J extends S{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}Symbol.asyncIterator;class R extends S{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class U extends S{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}const I=i.getRandomValues.bind(i);function O(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new _(`Unsupported JWE Algorithm: ${e}`)}}const D=e=>I(new Uint8Array(O(e)>>3)),x=(e,t)=>{if(t.length<<3!==O(e))throw new C("Invalid Initialization Vector length")},M=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new C(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)},j=(e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return 0===n};function N(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function $(e,t){return e.name===t}function B(e){return parseInt(e.name.slice(4),10)}function L(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function G(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!$(e.algorithm,"HMAC"))throw N("HMAC");const r=parseInt(t.slice(2),10);if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!$(e.algorithm,"RSASSA-PKCS1-v1_5"))throw N("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!$(e.algorithm,"RSA-PSS"))throw N("RSA-PSS");const r=parseInt(t.slice(2),10);if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw N("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!$(e.algorithm,"ECDSA"))throw N("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw N(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}L(e,r)}function F(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!$(e.algorithm,"AES-GCM"))throw N("AES-GCM");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw N(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!$(e.algorithm,"AES-KW"))throw N("AES-KW");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw N(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw N("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!$(e.algorithm,"PBKDF2"))throw N("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!$(e.algorithm,"RSA-OAEP"))throw N("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;if(B(e.algorithm.hash)!==r)throw N(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}L(e,r)}function V(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const z=(e,...t)=>V("Key must be ",e,...t);function X(e,t,...r){return V(`Key for the ${e} algorithm must be `,t,...r)}const Y=e=>s(e),q=["CryptoKey"];const Z=async(e,t,r,n,a,o)=>{if(!(s(t)||t instanceof Uint8Array))throw new TypeError(z(t,...q,"Uint8Array"));if(!n)throw new C("JWE Initialization Vector missing");if(!a)throw new C("JWE Authentication Tag missing");switch(x(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&M(t,parseInt(e.slice(-3),10)),async function(e,t,r,n,a,s){if(!(t instanceof Uint8Array))throw new TypeError(z(t,"Uint8Array"));const o=parseInt(e.slice(1,4),10),c=await i.subtle.importKey("raw",t.subarray(o>>3),"AES-CBC",!1,["decrypt"]),d=await i.subtle.importKey("raw",t.subarray(0,o>>3),{hash:"SHA-"+(o<<1),name:"HMAC"},!1,["sign"]),p=h(s,n,r,l(s.length<<3)),u=new Uint8Array((await i.subtle.sign("HMAC",d,p)).slice(0,o>>3));let y,w;try{y=j(a,u)}catch{}if(!y)throw new H;try{w=new Uint8Array(await i.subtle.decrypt({iv:n,name:"AES-CBC"},c,r))}catch{}if(!w)throw new H;return w}(e,t,r,n,a,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&M(t,parseInt(e.slice(1,4),10)),async function(e,t,r,n,a,s){let o;t instanceof Uint8Array?o=await i.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(F(t,e,"decrypt"),o=t);try{return new Uint8Array(await i.subtle.decrypt({additionalData:s,iv:n,name:"AES-GCM",tagLength:128},o,h(r,a)))}catch{throw new H}}(e,t,r,n,a,o);default:throw new _("Unsupported JWE Content Encryption Algorithm")}},Q=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const n of t){const e=Object.keys(n);if(r&&0!==r.size)for(const t of e){if(r.has(t))return!1;r.add(t)}else r=new Set(e)}return!0};function ee(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const te=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function re(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function ne(e,t,r){if(s(e))return F(e,t,r),e;if(e instanceof Uint8Array)return i.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(z(e,...q,"Uint8Array"))}const ae=async(e,t,r)=>{const n=await ne(t,e,"wrapKey");re(n,e);const a=await i.subtle.importKey("raw",r,...te);return new Uint8Array(await i.subtle.wrapKey("raw",a,n,"AES-KW"))},ie=async(e,t,r)=>{const n=await ne(t,e,"unwrapKey");re(n,e);const a=await i.subtle.unwrapKey("raw",r,n,"AES-KW",...te);return new Uint8Array(await i.subtle.exportKey("raw",a))};async function se(e,t,r,n,a=new Uint8Array(0),d=new Uint8Array(0)){if(!s(e))throw new TypeError(z(e,...q));if(F(e,"ECDH"),!s(t))throw new TypeError(z(t,...q));F(t,"ECDH","deriveBits");const p=h(w(c.encode(r)),w(a),w(d),y(n));let u;u="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,r){const n=Math.ceil((t>>3)/32),a=new Uint8Array(32*n);for(let i=0;i<n;i++){const t=new Uint8Array(4+e.length+r.length);t.set(y(i+1)),t.set(e,4),t.set(r,4+e.length),a.set(await o("sha256",t),32*i)}return a.slice(0,t>>3)}(new Uint8Array(await i.subtle.deriveBits({name:e.algorithm.name,public:e},t,u)),n,p)}function oe(e){if(!s(e))throw new TypeError(z(e,...q));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function ce(e,t,r,n){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new C("PBES2 Salt Input must be 8 or more octets")}(e);const a=function(e,t){return h(c.encode(e),new Uint8Array([0]),t)}(t,e),o=parseInt(t.slice(13,16),10),d={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:a},p={length:o,name:"AES-KW"},u=await function(e,t){if(e instanceof Uint8Array)return i.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(s(e))return F(e,t,"deriveBits","deriveKey"),e;throw new TypeError(z(e,...q,"Uint8Array"))}(n,t);if(u.usages.includes("deriveBits"))return new Uint8Array(await i.subtle.deriveBits(d,u,o));if(u.usages.includes("deriveKey"))return i.subtle.deriveKey(d,u,p,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function de(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new _(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}const pe=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function he(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new _(`Unsupported JWE Algorithm: ${e}`)}}const ue=e=>I(new Uint8Array(he(e)>>3)),le=(e,t)=>`-----BEGIN ${t}-----\n${(e.match(/.{1,64}/g)||[]).join("\n")}\n-----END ${t}-----`,ye=async(e,t,r)=>{if(!s(r))throw new TypeError(z(r,...q));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return le(f(new Uint8Array(await i.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},we=e=>ye("public","spki",e),fe=e=>ye("private","pkcs8",e),me=(e,t,r=0)=>{0===r&&(t.unshift(t.length),t.unshift(6));const n=e.indexOf(t[0],r);if(-1===n)return!1;const a=e.subarray(n,n+t.length);return a.length===t.length&&(a.every(((e,r)=>e===t[r]))||me(e,t,n+1))},ge=e=>{switch(!0){case me(e,[42,134,72,206,61,3,1,7]):return"P-256";case me(e,[43,129,4,0,34]):return"P-384";case me(e,[43,129,4,0,35]):return"P-521";case me(e,[43,101,110]):return"X25519";case me(e,[43,101,111]):return"X448";case me(e,[43,101,112]):return"Ed25519";case me(e,[43,101,113]):return"Ed448";default:throw new _("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},Ee=async(e,t,r,n,a)=>{let s,o;const c=new Uint8Array(atob(r.replace(e,"")).split("").map((e=>e.charCodeAt(0)))),d="spki"===t;switch(n){case"PS256":case"PS384":case"PS512":s={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},o=d?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":s={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},o=d?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},o=d?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":s={name:"ECDSA",namedCurve:"P-256"},o=d?["verify"]:["sign"];break;case"ES384":s={name:"ECDSA",namedCurve:"P-384"},o=d?["verify"]:["sign"];break;case"ES512":s={name:"ECDSA",namedCurve:"P-521"},o=d?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const e=ge(c);s=e.startsWith("P-")?{name:"ECDH",namedCurve:e}:{name:e},o=d?[]:["deriveBits"];break}case"EdDSA":s={name:ge(c)},o=d?["verify"]:["sign"];break;default:throw new _('Invalid or unsupported "alg" (Algorithm) value')}return i.subtle.importKey(t,c,s,a?.extractable??!1,o)},Se=(e,t,r)=>Ee(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r),Ae=(e,t,r)=>Ee(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function be(e){const t=[];let r=0;for(;r<e.length;){const n=ve(e.subarray(r));t.push(n),r+=n.byteLength}return t}function ve(e){let t=0,r=31&e[0];if(t++,31===r){for(r=0;e[t]>=128;)r=128*r+e[t]-128,t++;r=128*r+e[t]-128,t++}let n=0;if(e[t]<128)n=e[t],t++;else{if(128===n){for(n=0;0!==e[t+n]||0!==e[t+n+1];){if(n>e.byteLength)throw new TypeError("invalid indefinite form length");n++}const r=t+n+2;return{byteLength:r,contents:e.subarray(t,t+n),raw:e.subarray(0,r)}}{const r=127&e[t];t++,n=0;for(let a=0;a<r;a++)n=256*n+e[t],t++}}const a=t+n;return{byteLength:a,contents:e.subarray(t,a),raw:e.subarray(0,a)}}function _e(e){const t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),r=g(t);return le(function(e){const t=be(be(ve(e).contents)[0].contents);return f(t[160===t[0].raw[0]?6:5].raw)}(r),"PUBLIC KEY")}const He=(e,t,r)=>{let n;try{n=_e(e)}catch(a){throw new TypeError("Failed to parse the X.509 certificate",{cause:a})}return Ae(n,t,r)};const Ce=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=function(e){let t,r;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new _('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new _('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new _('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new _('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),n=[t,e.ext??!1,e.key_ops??r],a={...e};return delete a.alg,delete a.use,i.subtle.importKey("jwk",a,...n)};async function Pe(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN PUBLIC KEY-----"))throw new TypeError('"spki" must be SPKI formatted string');return Ae(e,t,r)}async function ke(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN CERTIFICATE-----"))throw new TypeError('"x509" must be X.509 formatted string');return He(e,t,r)}async function Ke(e,t,r){if("string"!=typeof e||0!==e.indexOf("-----BEGIN PRIVATE KEY-----"))throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return Se(e,t,r)}async function We(e,t){if(!ee(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return E(e.k);case"RSA":if(void 0!==e.oth)throw new _('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return Ce({...e,alg:t});default:throw new _('Unsupported "kty" (Key Type) Parameter value')}}const Te=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!Y(t))throw new TypeError(X(e,t,...q,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${q.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!Y(t))throw new TypeError(X(e,t,...q));if("secret"===t.type)throw new TypeError(`${q.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${q.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${q.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${q.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${q.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)};const Je=async(e,t,r,n,a)=>{if(!(s(r)||r instanceof Uint8Array))throw new TypeError(z(r,...q,"Uint8Array"));switch(x(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&M(r,parseInt(e.slice(-3),10)),async function(e,t,r,n,a){if(!(r instanceof Uint8Array))throw new TypeError(z(r,"Uint8Array"));const s=parseInt(e.slice(1,4),10),o=await i.subtle.importKey("raw",r.subarray(s>>3),"AES-CBC",!1,["encrypt"]),c=await i.subtle.importKey("raw",r.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),d=new Uint8Array(await i.subtle.encrypt({iv:n,name:"AES-CBC"},o,t)),p=h(a,n,d,l(a.length<<3));return{ciphertext:d,tag:new Uint8Array((await i.subtle.sign("HMAC",c,p)).slice(0,s>>3))}}(e,t,r,n,a);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&M(r,parseInt(e.slice(1,4),10)),async function(e,t,r,n,a){let s;r instanceof Uint8Array?s=await i.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(F(r,e,"encrypt"),s=r);const o=new Uint8Array(await i.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},s,t)),c=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:c}}(e,t,r,n,a);default:throw new _("Unsupported JWE Content Encryption Algorithm")}};const Re=async function(e,t,r,n,a){switch(Te(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new C("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new C("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ee(n.epk))throw new C('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!oe(t))throw new _("ECDH with the provided key is not allowed or not supported by your javascript runtime");const a=await We(n.epk,e);let i,s;if(void 0!==n.apu){if("string"!=typeof n.apu)throw new C('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{i=E(n.apu)}catch{throw new C("Failed to base64url decode the apu")}}if(void 0!==n.apv){if("string"!=typeof n.apv)throw new C('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{s=E(n.apv)}catch{throw new C("Failed to base64url decode the apv")}}const o=await se(a,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?he(n.enc):parseInt(e.slice(-5,-2),10),i,s);if("ECDH-ES"===e)return o;if(void 0===r)throw new C("JWE Encrypted Key missing");return ie(e.slice(-6),o,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new C("JWE Encrypted Key missing");return(async(e,t,r)=>{if(!s(t))throw new TypeError(z(t,...q));if(F(t,e,"decrypt","unwrapKey"),pe(e,t),t.usages.includes("decrypt"))return new Uint8Array(await i.subtle.decrypt(de(e),t,r));if(t.usages.includes("unwrapKey")){const n=await i.subtle.unwrapKey("raw",r,t,de(e),...te);return new Uint8Array(await i.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===r)throw new C("JWE Encrypted Key missing");if("number"!=typeof n.p2c)throw new C('JOSE Header "p2c" (PBES2 Count) missing or invalid');const i=a?.maxPBES2Count||1e4;if(n.p2c>i)throw new C('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof n.p2s)throw new C('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let s;try{s=E(n.p2s)}catch{throw new C("Failed to base64url decode the p2s")}return(async(e,t,r,n,a)=>{const i=await ce(a,e,n,t);return ie(e.slice(-6),i,r)})(e,t,r,n.p2c,s)}case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new C("JWE Encrypted Key missing");return ie(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===r)throw new C("JWE Encrypted Key missing");if("string"!=typeof n.iv)throw new C('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof n.tag)throw new C('JOSE Header "tag" (Authentication Tag) missing or invalid');let a,i;try{a=E(n.iv)}catch{throw new C("Failed to base64url decode the iv")}try{i=E(n.tag)}catch{throw new C("Failed to base64url decode the tag")}return async function(e,t,r,n,a){const i=e.slice(0,7);return Z(i,t,r,n,a,new Uint8Array(0))}(e,t,r,a,i)}default:throw new _('Invalid or unsupported "alg" (JWE Algorithm) header value')}};const Ue=function(e,t,r,n,a){if(void 0!==a.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const s of n.crit){if(!i.has(s))throw new _(`Extension Header Parameter "${s}" is not recognized`);if(void 0===a[s])throw new e(`Extension Header Parameter "${s}" is missing`);if(i.get(s)&&void 0===n[s])throw new e(`Extension Header Parameter "${s}" MUST be integrity protected`)}return new Set(n.crit)},Ie=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function Oe(e,t,r){if(!ee(e))throw new C("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new C("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new C("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new C("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new C("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new C("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new C("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new C("JWE AAD incorrect type");if(void 0!==e.header&&!ee(e.header))throw new C("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ee(e.unprotected))throw new C("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{const t=E(e.protected);n=JSON.parse(d.decode(t))}catch{throw new C("JWE Protected Header is invalid")}if(!Q(n,e.header,e.unprotected))throw new C("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const a={...n,...e.header,...e.unprotected};if(Ue(C,new Map,r?.crit,n,a),void 0!==a.zip)throw new _('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:i,enc:s}=a;if("string"!=typeof i||!i)throw new C("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof s||!s)throw new C("missing JWE Encryption Algorithm (enc) in JWE Header");const o=r&&Ie("keyManagementAlgorithms",r.keyManagementAlgorithms),p=r&&Ie("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(o&&!o.has(i)||!o&&i.startsWith("PBES2"))throw new v('"alg" (Algorithm) Header Parameter value not allowed');if(p&&!p.has(s))throw new v('"enc" (Encryption Algorithm) Header Parameter value not allowed');let u;if(void 0!==e.encrypted_key)try{u=E(e.encrypted_key)}catch{throw new C("Failed to base64url decode the encrypted_key")}let l,y,w,f=!1;"function"==typeof t&&(t=await t(n,e),f=!0);try{l=await Re(i,t,u,a,r)}catch(b){if(b instanceof TypeError||b instanceof C||b instanceof _)throw b;l=ue(s)}if(void 0!==e.iv)try{y=E(e.iv)}catch{throw new C("Failed to base64url decode the iv")}if(void 0!==e.tag)try{w=E(e.tag)}catch{throw new C("Failed to base64url decode the tag")}const m=c.encode(e.protected??"");let g,S;g=void 0!==e.aad?h(m,c.encode("."),c.encode(e.aad)):m;try{S=E(e.ciphertext)}catch{throw new C("Failed to base64url decode the ciphertext")}const A={plaintext:await Z(s,l,S,y,w,g)};if(void 0!==e.protected&&(A.protectedHeader=n),void 0!==e.aad)try{A.additionalAuthenticatedData=E(e.aad)}catch{throw new C("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(A.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(A.unprotectedHeader=e.header),f?{...A,key:t}:A}async function De(e,t,r){if(e instanceof Uint8Array&&(e=d.decode(e)),"string"!=typeof e)throw new C("Compact JWE must be a string or Uint8Array");const{0:n,1:a,2:i,3:s,4:o,length:c}=e.split(".");if(5!==c)throw new C("Invalid Compact JWE");const p=await Oe({ciphertext:s,iv:i||void 0,protected:n,tag:o||void 0,encrypted_key:a||void 0},t,r),h={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof t?{...h,key:p.key}:h}async function xe(e,t,r){if(!ee(e))throw new C("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(ee))throw new C("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new C("JWE Recipients has no members");for(const n of e.recipients)try{return await Oe({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new H}const Me=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:m(e)};if(!s(e))throw new TypeError(z(e,...q,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:n,use:a,...o}=await i.subtle.exportKey("jwk",e);return o};async function je(e){return we(e)}async function Ne(e){return fe(e)}async function $e(e){return Me(e)}const Be=async function(e,t,r,n,a={}){let o,c,d;switch(Te(e,r,"encrypt"),e){case"dir":d=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!oe(r))throw new _("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:p,apv:h}=a;let{epk:u}=a;u||(u=(await async function(e){if(!s(e))throw new TypeError(z(e,...q));return i.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(r)).privateKey);const{x:l,y:y,crv:w,kty:f}=await $e(u),g=await se(r,u,"ECDH-ES"===e?t:e,"ECDH-ES"===e?he(t):parseInt(e.slice(-5,-2),10),p,h);if(c={epk:{x:l,crv:w,kty:f}},"EC"===f&&(c.epk.y=y),p&&(c.apu=m(p)),h&&(c.apv=m(h)),"ECDH-ES"===e){d=g;break}d=n||ue(t);const E=e.slice(-6);o=await ae(E,g,d);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":d=n||ue(t),o=await(async(e,t,r)=>{if(!s(t))throw new TypeError(z(t,...q));if(F(t,e,"encrypt","wrapKey"),pe(e,t),t.usages.includes("encrypt"))return new Uint8Array(await i.subtle.encrypt(de(e),t,r));if(t.usages.includes("wrapKey")){const n=await i.subtle.importKey("raw",r,...te);return new Uint8Array(await i.subtle.wrapKey("raw",n,t,de(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,r,d);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{d=n||ue(t);const{p2c:i,p2s:s}=a;({encryptedKey:o,...c}=await(async(e,t,r,n=2048,a=I(new Uint8Array(16)))=>{const i=await ce(a,e,n,t);return{encryptedKey:await ae(e.slice(-6),i,r),p2c:n,p2s:m(a)}})(e,r,d,i,s));break}case"A128KW":case"A192KW":case"A256KW":d=n||ue(t),o=await ae(e,r,d);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{d=n||ue(t);const{iv:i}=a;({encryptedKey:o,...c}=await async function(e,t,r,n){const a=e.slice(0,7);n||(n=D(a));const{ciphertext:i,tag:s}=await Je(a,r,t,n,new Uint8Array(0));return{encryptedKey:i,iv:m(n),tag:m(s)}}(e,r,d,i));break}default:throw new _('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:d,encryptedKey:o,parameters:c}},Le=Symbol();class Ge{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new C("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!Q(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new C("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(Ue(C,new Map,t?.crit,this._protectedHeader,r),void 0!==r.zip)throw new _('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:a}=r;if("string"!=typeof n||!n)throw new C('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof a||!a)throw new C('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let i,s,o,p,u;if("dir"===n){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===n&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let r;({cek:s,encryptedKey:i,parameters:r}=await Be(n,a,e,this._cek,this._keyManagementParameters)),r&&(t&&Le in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...r}:this.setUnprotectedHeader(r):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...r}:this.setProtectedHeader(r))}this._iv||(this._iv=D(a)),p=this._protectedHeader?c.encode(m(JSON.stringify(this._protectedHeader))):c.encode(""),this._aad?(u=m(this._aad),o=h(p,c.encode("."),c.encode(u))):o=p;const{ciphertext:l,tag:y}=await Je(a,this._plaintext,s,this._iv,o),w={ciphertext:m(l),iv:m(this._iv),tag:m(y)};return i&&(w.encrypted_key=m(i)),u&&(w.aad=u),this._protectedHeader&&(w.protected=d.decode(p)),this._sharedUnprotectedHeader&&(w.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(w.header=this._unprotectedHeader),w}}class Fe{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class Ve{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const r=new Fe(this,e,{crit:t?.crit});return this._recipients.push(r),r}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new C("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new Ge(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),r={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(r.aad=t.aad),t.protected&&(r.protected=t.protected),t.unprotected&&(r.unprotected=t.unprotected),t.encrypted_key&&(r.recipients[0].encrypted_key=t.encrypted_key),t.header&&(r.recipients[0].header=t.header),r}let e;for(let n=0;n<this._recipients.length;n++){const t=this._recipients[n];if(!Q(this._protectedHeader,this._unprotectedHeader,t.unprotectedHeader))throw new C("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...t.unprotectedHeader},{alg:a}=r;if("string"!=typeof a||!a)throw new C('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===a||"ECDH-ES"===a)throw new C('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof r.enc||!r.enc)throw new C('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==r.enc)throw new C('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=r.enc;if(Ue(C,new Map,t.options.crit,this._protectedHeader,r),void 0!==r.zip)throw new _('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=ue(e),r={ciphertext:"",iv:"",recipients:[],tag:""};for(let n=0;n<this._recipients.length;n++){const a=this._recipients[n],i={};r.recipients.push(i);const s={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader}.alg.startsWith("PBES2")?2048+n:void 0;if(0===n){const e=await new Ge(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(a.unprotectedHeader).setKeyManagementParameters({p2c:s}).encrypt(a.key,{...a.options,[Le]:!0});r.ciphertext=e.ciphertext,r.iv=e.iv,r.tag=e.tag,e.aad&&(r.aad=e.aad),e.protected&&(r.protected=e.protected),e.unprotected&&(r.unprotected=e.unprotected),i.encrypted_key=e.encrypted_key,e.header&&(i.header=e.header);continue}const{encryptedKey:o,parameters:c}=await Be(a.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,a.key,t,{p2c:s});i.encrypted_key=m(o),(a.unprotectedHeader||c)&&(i.header={...a.unprotectedHeader,...c})}return r}}function ze(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new _(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function Xe(e,t,r){if(s(t))return G(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(z(t,...q));return i.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(z(t,...q,"Uint8Array"))}const Ye=async(e,t,r,n)=>{const a=await Xe(e,t,"verify");pe(e,a);const s=ze(e,a.algorithm);try{return await i.subtle.verify(s,a,r,n)}catch{return!1}};async function qe(e,t,r){if(!ee(e))throw new P("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new P('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new P("JWS Protected Header incorrect type");if(void 0===e.payload)throw new P("JWS Payload missing");if("string"!=typeof e.signature)throw new P("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ee(e.header))throw new P("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const t=E(e.protected);n=JSON.parse(d.decode(t))}catch{throw new P("JWS Protected Header is invalid")}if(!Q(n,e.header))throw new P("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header};let i=!0;if(Ue(P,new Map([["b64",!0]]),r?.crit,n,a).has("b64")&&(i=n.b64,"boolean"!=typeof i))throw new P('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=a;if("string"!=typeof s||!s)throw new P('JWS "alg" (Algorithm) Header Parameter missing or invalid');const o=r&&Ie("algorithms",r.algorithms);if(o&&!o.has(s))throw new v('"alg" (Algorithm) Header Parameter value not allowed');if(i){if("string"!=typeof e.payload)throw new P("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new P("JWS Payload must be a string or an Uint8Array instance");let p=!1;"function"==typeof t&&(t=await t(n,e),p=!0),Te(s,t,"verify");const u=h(c.encode(e.protected??""),c.encode("."),"string"==typeof e.payload?c.encode(e.payload):e.payload);let l;try{l=E(e.signature)}catch{throw new P("Failed to base64url decode the signature")}if(!await Ye(s,t,l,u))throw new U;let y;if(i)try{y=E(e.payload)}catch{throw new P("Failed to base64url decode the payload")}else y="string"==typeof e.payload?c.encode(e.payload):e.payload;const w={payload:y};return void 0!==e.protected&&(w.protectedHeader=n),void 0!==e.header&&(w.unprotectedHeader=e.header),p?{...w,key:t}:w}async function Ze(e,t,r){if(e instanceof Uint8Array&&(e=d.decode(e)),"string"!=typeof e)throw new P("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:i,length:s}=e.split(".");if(3!==s)throw new P("Invalid Compact JWS");const o=await qe({payload:a,protected:n,signature:i},t,r),c={payload:o.payload,protectedHeader:o.protectedHeader};return"function"==typeof t?{...c,key:o.key}:c}async function Qe(e,t,r){if(!ee(e))throw new P("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(ee))throw new P("JWS Signatures missing or incorrect type");for(const n of e.signatures)try{return await qe({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch{}throw new U}const et=e=>Math.floor(e.getTime()/1e3),tt=86400,rt=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,nt=e=>{const t=rt.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]);let n;switch(t[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":n=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":n=Math.round(60*r);break;case"hour":case"hours":case"hr":case"hrs":case"h":n=Math.round(3600*r);break;case"day":case"days":case"d":n=Math.round(r*tt);break;case"week":case"weeks":case"w":n=Math.round(604800*r);break;default:n=Math.round(31557600*r)}return"-"===t[1]||"ago"===t[4]?-n:n},at=e=>e.toLowerCase().replace(/^application\//,""),it=(e,t,r={})=>{const{typ:n}=r;if(n&&("string"!=typeof e.typ||at(e.typ)!==at(n)))throw new A('unexpected "typ" JWT header value',"typ","check_failed");let a;try{a=JSON.parse(d.decode(t))}catch{}if(!ee(a))throw new k("JWT Claims Set must be a top-level JSON object");const{requiredClaims:i=[],issuer:s,subject:o,audience:c,maxTokenAge:p}=r,h=[...i];void 0!==p&&h.push("iat"),void 0!==c&&h.push("aud"),void 0!==o&&h.push("sub"),void 0!==s&&h.push("iss");for(const d of new Set(h.reverse()))if(!(d in a))throw new A(`missing required "${d}" claim`,d,"missing");if(s&&!(Array.isArray(s)?s:[s]).includes(a.iss))throw new A('unexpected "iss" claim value',"iss","check_failed");if(o&&a.sub!==o)throw new A('unexpected "sub" claim value',"sub","check_failed");if(c&&(u=a.aud,l="string"==typeof c?[c]:c,!("string"==typeof u?l.includes(u):Array.isArray(u)&&l.some(Set.prototype.has.bind(new Set(u))))))throw new A('unexpected "aud" claim value',"aud","check_failed");var u,l;let y;switch(typeof r.clockTolerance){case"string":y=nt(r.clockTolerance);break;case"number":y=r.clockTolerance;break;case"undefined":y=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:w}=r,f=et(w||new Date);if((void 0!==a.iat||p)&&"number"!=typeof a.iat)throw new A('"iat" claim must be a number',"iat","invalid");if(void 0!==a.nbf){if("number"!=typeof a.nbf)throw new A('"nbf" claim must be a number',"nbf","invalid");if(a.nbf>f+y)throw new A('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==a.exp){if("number"!=typeof a.exp)throw new A('"exp" claim must be a number',"exp","invalid");if(a.exp<=f-y)throw new b('"exp" claim timestamp check failed',"exp","check_failed")}if(p){const e=f-a.iat;if(e-y>("number"==typeof p?p:nt(p)))throw new b('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-y)throw new A('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return a};async function st(e,t,r){const n=await Ze(e,t,r);if(n.protectedHeader.crit?.includes("b64")&&!1===n.protectedHeader.b64)throw new k("JWTs MUST NOT use unencoded payload");const a={payload:it(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return"function"==typeof t?{...a,key:n.key}:a}async function ot(e,t,r){const n=await De(e,t,r),a=it(n.protectedHeader,n.plaintext,r),{protectedHeader:i}=n;if(void 0!==i.iss&&i.iss!==a.iss)throw new A('replicated "iss" claim header parameter mismatch',"iss","mismatch");if(void 0!==i.sub&&i.sub!==a.sub)throw new A('replicated "sub" claim header parameter mismatch',"sub","mismatch");if(void 0!==i.aud&&JSON.stringify(i.aud)!==JSON.stringify(a.aud))throw new A('replicated "aud" claim header parameter mismatch',"aud","mismatch");const s={payload:a,protectedHeader:i};return"function"==typeof t?{...s,key:n.key}:s}class ct{constructor(e){this._flattened=new Ge(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}const dt=async(e,t,r)=>{const n=await Xe(e,t,"sign");pe(e,n);const a=await i.subtle.sign(ze(e,n.algorithm),n,r);return new Uint8Array(a)};class pt{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new P("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!Q(this._protectedHeader,this._unprotectedHeader))throw new P("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader};let n=!0;if(Ue(P,new Map([["b64",!0]]),t?.crit,this._protectedHeader,r).has("b64")&&(n=this._protectedHeader.b64,"boolean"!=typeof n))throw new P('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:a}=r;if("string"!=typeof a||!a)throw new P('JWS "alg" (Algorithm) Header Parameter missing or invalid');Te(a,e,"sign");let i,s=this._payload;n&&(s=c.encode(m(s))),i=this._protectedHeader?c.encode(m(JSON.stringify(this._protectedHeader))):c.encode("");const o=h(i,c.encode("."),s),p=await dt(a,e,o),u={signature:m(p),payload:""};return n&&(u.payload=d.decode(s)),this._unprotectedHeader&&(u.header=this._unprotectedHeader),this._protectedHeader&&(u.protected=d.decode(i)),u}}class ht{constructor(e){this._flattened=new pt(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class ut{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class lt{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const r=new ut(this,e,t);return this._signatures.push(r),r}async sign(){if(!this._signatures.length)throw new P("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const r=this._signatures[t],n=new pt(this._payload);n.setProtectedHeader(r.protectedHeader),n.setUnprotectedHeader(r.unprotectedHeader);const{payload:a,...i}=await n.sign(r.key,r.options);if(0===t)e.payload=a;else if(e.payload!==a)throw new P("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(i)}return e}}function yt(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}class wt{constructor(e={}){if(!ee(e))throw new TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){return this._payload={...this._payload,iss:e},this}setSubject(e){return this._payload={...this._payload,sub:e},this}setAudience(e){return this._payload={...this._payload,aud:e},this}setJti(e){return this._payload={...this._payload,jti:e},this}setNotBefore(e){return"number"==typeof e?this._payload={...this._payload,nbf:yt("setNotBefore",e)}:e instanceof Date?this._payload={...this._payload,nbf:yt("setNotBefore",et(e))}:this._payload={...this._payload,nbf:et(new Date)+nt(e)},this}setExpirationTime(e){return"number"==typeof e?this._payload={...this._payload,exp:yt("setExpirationTime",e)}:e instanceof Date?this._payload={...this._payload,exp:yt("setExpirationTime",et(e))}:this._payload={...this._payload,exp:et(new Date)+nt(e)},this}setIssuedAt(e){return void 0===e?this._payload={...this._payload,iat:et(new Date)}:e instanceof Date?this._payload={...this._payload,iat:yt("setIssuedAt",et(e))}:this._payload="string"==typeof e?{...this._payload,iat:yt("setIssuedAt",et(new Date)+nt(e))}:{...this._payload,iat:yt("setIssuedAt",e)},this}}class ft extends wt{setProtectedHeader(e){return this._protectedHeader=e,this}async sign(e,t){const r=new ht(c.encode(JSON.stringify(this._payload)));if(r.setProtectedHeader(this._protectedHeader),Array.isArray(this._protectedHeader?.crit)&&this._protectedHeader.crit.includes("b64")&&!1===this._protectedHeader.b64)throw new k("JWTs MUST NOT use unencoded payload");return r.sign(e,t)}}class mt extends wt{setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(e,t){const r=new ct(c.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),r.setProtectedHeader(this._protectedHeader),this._iv&&r.setInitializationVector(this._iv),this._cek&&r.setContentEncryptionKey(this._cek),this._keyManagementParameters&&r.setKeyManagementParameters(this._keyManagementParameters),r.encrypt(e,t)}}const gt=(e,t)=>{if("string"!=typeof e||!e)throw new K(`${t} missing or invalid`)};async function Et(e,t){if(!ee(e))throw new TypeError("JWK must be an object");if(t??(t="sha256"),"sha256"!==t&&"sha384"!==t&&"sha512"!==t)throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let r;switch(e.kty){case"EC":gt(e.crv,'"crv" (Curve) Parameter'),gt(e.x,'"x" (X Coordinate) Parameter'),gt(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":gt(e.crv,'"crv" (Subtype of Key Pair) Parameter'),gt(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":gt(e.e,'"e" (Exponent) Parameter'),gt(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":gt(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new _('"kty" (Key Type) Parameter missing or unsupported')}const n=c.encode(JSON.stringify(r));return m(await o(t,n))}async function St(e,t){t??(t="sha256");const r=await Et(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function At(e,t){const r={...e,...t?.header};if(!ee(r.jwk))throw new P('"jwk" (JSON Web Key) Header Parameter must be a JSON object');const n=await We({...r.jwk,ext:!0},r.alg);if(n instanceof Uint8Array||"public"!==n.type)throw new P('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function bt(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(vt)}function vt(e){return ee(e)}class _t{constructor(e){if(this._cached=new WeakMap,!bt(e))throw new W("JSON Web Key Set malformed");var t;this._jwks=(t=e,"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t)))}async getKey(e,t){const{alg:r,kid:n}={...e,...t?.header},a=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new _('Unsupported "alg" value for a JSON Web Key Set')}}(r),i=this._jwks.keys.filter((e=>{let t=a===e.kty;if(t&&"string"==typeof n&&(t=n===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv}return t})),{0:s,length:o}=i;if(0===o)throw new T;if(1!==o){const e=new J,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of i)try{yield await Ht(t,e,r)}catch{}},e}return Ht(this._cached,s,r)}}async function Ht(e,t,r){const n=e.get(t)||e.set(t,{}).get(t);if(void 0===n[r]){const e=await We({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new W("JSON Web Key Set members must be public keys");n[r]=e}return n[r]}function Ct(e){const t=new _t(e);return async(e,r)=>t.getKey(e,r)}const Pt=async(e,t,r)=>{let n,a,i=!1;"function"==typeof AbortController&&(n=new AbortController,a=setTimeout((()=>{i=!0,n.abort()}),t));const s=await fetch(e.href,{signal:n?n.signal:void 0,redirect:"manual",headers:r.headers}).catch((e=>{if(i)throw new R;throw e}));if(void 0!==a&&clearTimeout(a),200!==s.status)throw new S("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await s.json()}catch{throw new S("Failed to parse the JSON Web Key Set HTTP response as JSON")}};let kt;if("undefined"==typeof navigator||!navigator.userAgent?.startsWith?.("Mozilla/5.0 ")){kt=`${"jose"}/${"v5.2.2"}`}class Kt extends _t{constructor(e,t){if(super({keys:[]}),this._jwks=void 0,!(e instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(e.href),this._options={agent:t?.agent,headers:t?.headers},this._timeoutDuration="number"==typeof t?.timeoutDuration?t?.timeoutDuration:5e3,this._cooldownDuration="number"==typeof t?.cooldownDuration?t?.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof t?.cacheMaxAge?t?.cacheMaxAge:6e5}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._jwks&&this.fresh()||await this.reload();try{return await super.getKey(e,t)}catch(r){if(r instanceof T&&!1===this.coolingDown())return await this.reload(),super.getKey(e,t);throw r}}async reload(){this._pendingFetch&&("undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)&&(this._pendingFetch=void 0);const e=new Headers(this._options.headers);kt&&!e.has("User-Agent")&&(e.set("User-Agent",kt),this._options.headers=Object.fromEntries(e.entries())),this._pendingFetch||(this._pendingFetch=Pt(this._url,this._timeoutDuration,this._options).then((e=>{if(!bt(e))throw new W("JSON Web Key Set malformed");this._jwks={keys:e.keys},this._jwksTimestamp=Date.now(),this._pendingFetch=void 0})).catch((e=>{throw this._pendingFetch=void 0,e}))),await this._pendingFetch}}function Wt(e,t){const r=new Kt(e,t);return async(e,t)=>r.getKey(e,t)}class Tt extends wt{encode(){return`${m(JSON.stringify({alg:"none"}))}.${m(JSON.stringify(this._payload))}.`}static decode(e,t){if("string"!=typeof e)throw new k("Unsecured JWT must be a string");const{0:r,1:n,2:a,length:i}=e.split(".");if(3!==i||""!==a)throw new k("Invalid Unsecured JWT");let s;try{if(s=JSON.parse(d.decode(E(r))),"none"!==s.alg)throw new Error}catch{throw new k("Invalid Unsecured JWT")}return{payload:it(s,E(n),t),header:s}}}const Jt=m,Rt=E;function Ut(e){let t;if("string"==typeof e){const r=e.split(".");3!==r.length&&5!==r.length||([t]=r)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(d.decode(Rt(t)));if(!ee(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function It(e){if("string"!=typeof e)throw new k("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:r}=e.split(".");if(5===r)throw new k("Only JWTs using Compact JWS serialization can be decoded");if(3!==r)throw new k("Invalid JWT");if(!t)throw new k("JWTs must contain a payload");let n,a;try{n=Rt(t)}catch{throw new k("Failed to base64url decode the payload")}try{a=JSON.parse(d.decode(n))}catch{throw new k("Failed to parse the decoded payload as JSON")}if(!ee(a))throw new k("Invalid JWT Claims Set");return a}function Ot(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new _("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Dt(e,t){return async function(e,t){let r,n;switch(e){case"PS256":case"PS384":case"PS512":r={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ot(t)},n=["sign","verify"];break;case"RS256":case"RS384":case"RS512":r={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ot(t)},n=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":r={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ot(t)},n=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":r={name:"ECDSA",namedCurve:"P-256"},n=["sign","verify"];break;case"ES384":r={name:"ECDSA",namedCurve:"P-384"},n=["sign","verify"];break;case"ES512":r={name:"ECDSA",namedCurve:"P-521"},n=["sign","verify"];break;case"EdDSA":{n=["sign","verify"];const e=t?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":r={name:e};break;default:throw new _("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{n=["deriveKey","deriveBits"];const e=t?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":r={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":r={name:e};break;default:throw new _("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new _('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return i.subtle.generateKey(r,t?.extractable??!1,n)}(e,t)}async function xt(e,t){return async function(e,t){let r,n,a;switch(e){case"HS256":case"HS384":case"HS512":r=parseInt(e.slice(-3),10),n={name:"HMAC",hash:`SHA-${r}`,length:r},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r=parseInt(e.slice(-3),10),I(new Uint8Array(r>>3));case"A128KW":case"A192KW":case"A256KW":r=parseInt(e.slice(1,4),10),n={name:"AES-KW",length:r},a=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.slice(1,4),10),n={name:"AES-GCM",length:r},a=["encrypt","decrypt"];break;default:throw new _('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return i.subtle.generateKey(n,t?.extractable??!1,a)}(e,t)}const Mt="WebCryptoAPI"}}]);