"use strict";(self.webpackChunkapp_docs=self.webpackChunkapp_docs||[]).push([[9476],{6746:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=n(5893),a=n(1151);const i={sidebar_position:10,description:"Examples"},o="Examples",r={id:"libraries/examples",title:"Examples",description:"Examples",source:"@site/docs/libraries/10-examples.md",sourceDirName:"libraries",slug:"/libraries/examples",permalink:"/docs/libraries/examples",draft:!1,unlisted:!1,editUrl:"https://github.com/nevermined-io/app_docs/tree/main/docs/libraries/10-examples.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10,description:"Examples"},sidebar:"tutorialSidebar",previous:{title:"How AI Builders can process AI Tasks?",permalink:"/docs/libraries/process-tasks"},next:{title:"Getting Started with the Tutorials",permalink:"/docs/tutorials/"}},p={},d=[{value:"AI Agents",id:"ai-agents",level:2},{value:"Youtube Agent (Python)",id:"youtube-agent-python",level:3},{value:"Notebooks",id:"notebooks",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"examples",children:"Examples"})}),"\n",(0,s.jsx)(t.p,{children:"The Payment Libraries allow you to interact with the Nevermined platform to create and manage Payment Plans and AI Agents."}),"\n",(0,s.jsx)(t.h2,{id:"ai-agents",children:"AI Agents"}),"\n",(0,s.jsx)(t.h3,{id:"youtube-agent-python",children:"Youtube Agent (Python)"}),"\n",(0,s.jsx)(t.p,{children:"The Youtube Summarizer it's a small Python AI Agent with Nevermined Payments Library integrated which receives a Youtube video URL and returns a summary of the transcription of the video."}),"\n",(0,s.jsx)(t.p,{children:"The Agent uses LangChain to retrieve the transcription and summarize it via OpenAI integration."}),"\n",(0,s.jsxs)(t.p,{children:["Here is the ",(0,s.jsx)(t.a,{href:"https://github.com/nevermined-io/youtube-agent/",children:"Youtube Summarizer Agent code"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"As you can see, the Agent is a simple Python script that implements a callback function to process the AI Tasks that are sent by the users."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class YoutubeAgent:\n    def __init__(self, payment):\n        self.payment = payment\n\n    async def run(self, data):\n        print(\"Data received:\", data)\n        step = self.payment.ai_protocol.get_step(data['step_id'])\n\n        loader = YoutubeLoader.from_youtube_url(\n            youtube_url=step['input_query'],\n            add_video_info=False, \n            language=[\"en\"],\n            transcript_format=TranscriptFormat.CHUNKS, \n            chunk_size_seconds=30,\n        )\n        # Load the documents from the video\n        docs = loader.load()\n        result = \" \".join(doc.page_content for doc in docs)\n\n        llm = OpenAI(api_key=openai_api_key)\n        summarize_chain = load_summarize_chain(llm, chain_type=\"map_reduce\")\n        docs = [Document(page_content=result)]\n        summary = summarize_chain.invoke(docs)\n        print('Summary:', summary['output_text'])\n\n\n        # Use the `payment` object to update the step\n        self.payment.ai_protocol.update_step(\n            did=data['did'],\n            task_id=data['task_id'], \n            step_id=data['step_id'],\n            step={'step_id': data['step_id'],\n                    'task_id': data[\"task_id\"], \n                    'step_status': AgentExecutionStatus.Completed.value,\n                    'output': summary['output_text'],\n                    'is_last': True\n                    },\n        )\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As you can see the fuction ",(0,s.jsx)(t.code,{children:"run"})," is the callback function that processes the AI Task. The function receives the data from the AI Task and uses it to process the task. In this case, the function uses the data to retrieve the Youtube video URL, transcribe it, and summarize it. After processing you have to update the step with the result."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'async def main():\n    # Initialize the Payments object\n    payment = Payments(\n        app_id="youtube_agent", \n        nvm_api_key=nvm_api_key, \n        version="1.0.0", \n        environment=Environment.get_environment(environment), \n        ai_protocol=True, \n        web_socket_options={\'bearer_token\': nvm_api_key}\n    )\n\n    # Initialize the YoutubeAgent with the payment instance\n    agent = YoutubeAgent(payment)\n\n    # Subscribe to the ai_protocol with the agent\'s `run` method\n    subscription_task = asyncio.get_event_loop().create_task(payment.ai_protocol.subscribe(agent.run, join_account_room=True))\n    try:\n        await subscription_task\n    except asyncio.CancelledError:\n        print("Subscription task was cancelled")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"main"})," function initializes the Payments object and the YoutubeAgent object. Then it subscribes to the ai_protocol with the agent's ",(0,s.jsx)(t.code,{children:"run"})," method.\nIn this example we are asuming that the agent is processing the AI task in one step, but you can implement the agent to process multiple steps."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class YoutubeAgent:\n    def __init__(self, payment):\n        self.payment = payment\n\n    async def run(self, data):\n        step = self.payment.ai_protocol.get_step(data['step_id'])\n        if(step['step_status'] != AgentExecutionStatus.Pending.value):\n            print('Step status is not pending')\n            return\n        \n        if(step['name'] == 'init'):\n            transcript_step_id = generate_step_id()\n            self.payment.ai_protocol.create_steps(did=step['did'], task_id=step['task_id'], steps={\"steps\" : [{\n                'task_id': step['task_id'],\n                'step_id': transcript_step_id,\n                'input_query': step['input_query'],\n                'name': 'transcript',\n                'predecessor': step['step_id'],\n                'is_last': False,\n                'order': 2\n                },\n                {                \n                'task_id': step['task_id'],\n                'step_id': generate_step_id(),\n                'predecessor': transcript_step_id,\n                'input_query': '',\n                'name': 'summarize',\n                'is_waiting': True, \n                'is_last': True,\n                'order': 3\n            }]})\n            self.payment.ai_protocol.update_step(\n                did=step['did'],\n                task_id=step['task_id'], \n                step_id=step['step_id'],\n                step={'step_id': step['step_id'],\n                        'task_id': step[\"task_id\"], \n                        'step_status': AgentExecutionStatus.Completed.value,\n                        'input_query': step['input_query'],\n                        'output': step['input_query'],\n                        'is_last': False\n                        },\n            )\n        \n        elif (step['name'] == 'transcript'):\n            loader = YoutubeLoader.from_youtube_url(\n                youtube_url=step['input_query'],\n                add_video_info=False, \n                language=[\"en\"],\n                transcript_format=TranscriptFormat.CHUNKS, \n                chunk_size_seconds=30,\n            )\n            # Load the documents from the video\n            docs = loader.load()\n            result = \" \".join(doc.page_content for doc in docs)\n            self.payment.ai_protocol.update_step(\n                did=step['did'],\n                task_id=step['task_id'], \n                step_id=step['step_id'],\n                step={'step_id': step['step_id'],\n                        'task_id': step[\"task_id\"], \n                        'step_status': AgentExecutionStatus.Completed.value,\n                        'output': result,\n                        'is_last': False\n                        },\n            )\n        \n        elif (step['name'] == 'summarize'):\n            llm = OpenAI(api_key=openai_api_key)\n            summarize_chain = load_summarize_chain(llm, chain_type=\"map_reduce\")\n            docs = [Document(page_content=step[\"input_query\"])]\n            summary = summarize_chain.invoke(docs)\n            print('Summary:', summary['output_text'])\n            # Use the `payment` object to update the step\n            self.payment.ai_protocol.update_step(\n                did=step['did'],\n                task_id=step['task_id'], \n                step_id=step['step_id'],\n                step={'step_id': step['step_id'],\n                        'task_id': step[\"task_id\"], \n                        'step_status': AgentExecutionStatus.Completed.value,\n                        'output': summary['output_text'],\n                        'is_last': True\n                        },\n            )\n        \n        else:\n            print(f\"Unknown step name: {step['name']}\")\n"})}),"\n",(0,s.jsx)(t.p,{children:"In this example, we are assuming that the agent is processing the AI task in multiple steps. The agent receives the data from the AI Task and uses it to process the task.\nAfter processing you have to update the step with the result. Automatically the output of the previous step is the input of the next step."}),"\n",(0,s.jsx)(t.h2,{id:"notebooks",children:"Notebooks"}),"\n",(0,s.jsxs)(t.p,{children:["In the ",(0,s.jsx)(t.a,{href:"https://colab.research.google.com/drive/1Pqrfm3P5t8P9DS7Hwp3v72jhRrB2KsP5#scrollTo=dghI-HwVgulp",children:"Python Notebook"})," example, we will show you how to use the Payments Library to create Payment Plans, register AI Agents, and query them."]})]})}function c(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var s=n(7294);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);